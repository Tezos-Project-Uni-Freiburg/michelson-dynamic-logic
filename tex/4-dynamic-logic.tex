\section{Dynamic Logic for Michelson}
\label{sec:DL}

To obtain a dynamic logic suitable for symbolic execution we follow
the Key approach \cite{KeY3} and extend
first order logic with a modality $[p]$, where $p$ is a program state. The
intuitive meaning is that $[p]\Psi$ holds for a formula $\Psi$, if
running $p$ terminates in a state such that $\Psi$ holds. That is, the
formula $\Phi \to [p]\Psi$ has a similar meaning as the Hoare triple
$\{\Phi\}~p~\{ \Psi\}$.

In the following, we concentrate on the proof rules for the
modality. For instance (and ignoring the details of the program state
for now), $\Phi \to [end]\Psi \equiv \Phi \to \Psi$ if the program is
empty. Many simple proof rules have the form $\Phi \to [i; p]\Psi \equiv \Phi_i
\wedge\Phi \to  [p]\Psi$ where the formula $\Phi_i$ describes the effect of
instruction $i$. If the instruction is a branch instruction on a
predicate $Q$, like $\mathtt{if}~Q~p_1~p_2$, the resulting fomula is a
disjunction as in $\Phi \to [(\mathtt{if}~Q~p_1~p_2); p]\Psi \equiv Q
\wedge \Phi \to [p_1; p]\Psi \vee \neg Q \wedge \Phi \to  [p_2; p]\Psi$.

We start by defining the formulas of the logic in \autoref{sec:terms-formulas}.

\subsection{Terms and Formulas}\label{sec:terms-formulas}
\begin{figure}[tp]
  \AbstractTerm
  \AbstractFormula
  \caption{Terms and formulas}
  \label{fig:terms-and-formulas}
\end{figure}

At the core of any symbolic execution there are symbolic (i.e., logical) variables
representing the unknown operands.
We represent such variables by a typed deBruijn index into a given
{\AbstractContext}.
An abstract stack is then a list of typed variables:
\AbstractMatch

\autoref{fig:terms-and-formulas} shows the terms and formulas used for the logic.
Term comprise variables, constants of base type and of contract type,
and simple functions. Here, ``function'' stands for proper functions as
well as data constructors. For convenience, we restrict function arguments
to variables and rely on variable equality in the formulas to specify
complex terms. 
% The term for subtracting mutez' is not representable with a functional Michelson instruction
% and therefore defined as a separate term.

Formulas are restricted to express equality of a variable with a term
and to impose order on tokens. The latter is used for token transfers
where we have to know that the sender has sufficient tokens to satisfy
the requirements of the transfer. The reader may wonder about 
conjunction and disjunction: the proof rules only generate them in the
form of a disjunction of conjunctions of simple formulas.  We
represent this structure as a list of lists of simple formulas.


\subsection{Representing Michelson Programs in DL}\label{sec:abstract-states}

We simplify the handling of formulas of the form $\Phi \to [p]\Psi$ by
reusing our previous definition of the type \ADT{ProgState} in a
different mode as an \emph{abstract} state.
\AbstractAMode
That is, we replace the normal representation of values by symbolic
variables, in $\mathcal{F}$ we maintain a list (i.e., conjunction) of
formulas, and in $\mathcal{G}$ we maintain a tagged list of formulas
to represent different modes of failure. 

The meaning of an abstract state is a conjunction that specifies the
value for \ACon{AMOUNT} and \ACon{BALANCE} in the environment, it
specifies the size of the stack and all values on it, and it collects
further constraints generated by application of the proof rules.



\begin{comment}
  The main focus of this thesis is the developement of symbolic
  execution rules that are used to reduce the programs in such
  formulas successively until one is left with a purely first formula
  that does not include any more program statements.  We only give the
  formalization of these symbolic execution rules in Agda since the
  resulting first order formulas do not contain Michelson specific
  aspects and can be easily formalized like any other first order
  logic.  See \cite{KeY2,DL} for more information on that topic.

  Analogous to the two different execution models for Michelson, one
  only for programs and one for contract execution chains, the
  symbolic execution rules are given for programs and contract
  execution chains as well.  In case of contract execution chains,
  this formalizes a dynamic logic that extends the DL about Michelson
  programs to one about blockchain operations.

  For a DL in general the preconditions can be empty, but our
  formalization in Agda will always assume some preconditions, which
  makes sense in both cases: Even when reasoning about a program that
  does not consume any stack elements (e.g. proving something about
  the values the program pushed onto the stack), we can only ever
  prove something about the resulting values of stack elements, and to
  reference their position on the stack we would assume that the
  initial stack is empty.
  % This formalization generalizes to be correct for any unaffected
  % substack.  For Contract executions, they terminate when all
  % pending operations have been accounted for,
  To save the results from modeling a contract execution, it must at
  least be assumed that the contract under consideration is present in
  the blockchain.  So both formalizations always include at least some
  preconditions on the input stacks or the state of the blockchain.
\end{comment}
\begin{comment}
Most rules of the presented Michelson DL calculus have the form:
\begin{align*}
  Pre  &\Longrightarrow \langle i ; p \rangle Ass
  \\ \leftrightarrow \qquad I \land  Pre' &\Longrightarrow \langle     p \rangle Ass
\end{align*}

where $I$ is a new clause containing new variables and variables from
$Pre$, and $Pre'$ only differs from $Pre$ in clauses about the state
of the stacks.  For control flow instructions the rules may contain
disjunctions and subprogram expansions:
\begin{align*}
  Pre  &\Longrightarrow \langle i    ; p \rangle Ass
  \\ \leftrightarrow \qquad (I \land Pre'  \Longrightarrow \langle p'  ;; p \rangle Ass)
       &\lor  (J \land Pre'' \Longrightarrow \langle p'' ;; p \rangle Ass)
\end{align*}

Notice that $Ass$ is never affected.  This is unlike the calculus of
Dynamic Logics for other programming languages where an assignment
might affect the value of a variable contained in $Ass$.  But
Michelson does not have any variables and therefore no assignments to
them, so we are able to neglect $Ass$ when formalizing the symbolic
execution rules.  So our formalization will specify how we get from
$Pre$ to $I \land Pre'$ when symbolically executing instruction $i$,
where $Pre$ is a conjunction of formulas that will always include
statements about the program stacks as well as the execution
environment (which is necessary to execute \verb/env-func/
instructions).  That is when we only deal with symbolic program
execution; in case of contract execution chains, $Pre$ will always
contain statements about the state of the blockchain, as well as some
additional information in cases where a currently running contract
execution is formalized.
\end{comment}
\begin{comment}
  These rules never affect the goal formula to be asserted, and
  because (which must always be given), and $Ass$ can be any formula.
  Our construct specifys $Pre \Longrightarrow \langle p \rangle$ but
  not $Ass$ since it neither changes, nor has any implications for the
  validity of our rules \draft{other than the premisse holds with
    $Ass$ \emph{iff} the conclusion holds with it (i guess)}.

  This matches the sequent rule (R8) from \todo{cite lecture notes
    2010} for functional Michelson instructions, since here $x$ will
  be the new top stack element, which our DL always represents with a
  new variable, thus $\phi_x^{\hat{x}} \equiv \phi$.  \todo{not sure
    about control flow instructions \ldots}

  We will proof the soundness of these rules by showing that if an
  interpretation for $Pre$ is a valid interpretation for a concrete
  execution state with $i ; p$ left to be executed (i.e. stack values
  match and $Pre$ otherwise doesn't contradict itself), we can give an
  extension of that interpretation such that $I \land Pre'$ is a valid
  interpretation of the concrete state after execution of $i$.

  Since the extension of the interpretation is only for possible new
  variables that are not present in $Ass$, it follows from our
  soundness proof \draft{that our calculus is sound \ldots}.
\end{comment}

Informally, an abstract program state
represents $\Theta \Longrightarrow \langle prg \rangle \Psi$ where
\begin{align*}
	\Theta&\equiv	\text{\emph{state of environment}} = \alpha en
\land	\text{\emph{state of stack}} = rSI
\land	\bigwedge_{\phi \in \Phi} \phi
\end{align*}


This encoding makes the formalization of symbolic execution very similar to the concrete execution model
presented in~\autoref{sec:refImpl}.
This similarity in turn makes the soundness proof easier and more concise.
All constructs for concrete execution are reused in the abstract by
instantiating their \ADT{MODE} parameter.
Thus, they  are automatically parameterized by a \verb/Context Γ/ and the names of the
structures are the same as for concrete execution but prefixed with an \verb/α/
(only the abstract blockchain is called \verb/βlockchain/).


Symbolic execution can lead to disjunctions over such states, which is presented using
a list of abstract program states.
\AbstractUProgState
% \mint{agda}|⊎Prog-state = λ {ro} {so} → List (∃[ Γ ] αProg-state Γ {ro} {so})|

Using Agda lists to represent conjunctions and disjunctions is
convenient for two reasons.
\begin{enumerate}
\item Conjunctions and disjunctions do not mix: $\Phi$ always represents a conjunction over its elements
  and disjunctions can only occur as a result of some
  symbolic execution rules that implement control flow. 
  In this case, the disjunction always affects every aspect of the abstract program state
  (i.e., the remaining programs will always differ).
\item Agda's ``element of'' relation for lists makes the
  implementation of the rules of the calculus simpler and more efficient.
\end{enumerate}

\subsection{Calculus for Michelson DL}\label{sec:calculus}

The rules for symbolic execution are formalized by a function that
maps an abstract program state into a set (list) of abstract program states.
\AbstractProgStep

It mimics \AFun{prog-step} and gives a deterministic way of symbolic execution.
Every (non-environmental) functional instruction can be executed concretely
with a single rule as shown in \autoref{fig:exec-step-1}.
During symbolic execution, the only thing that is guaranteed is
that the stacks contain values of the expected type.
For example, if the next instruction is \ACon{ADDnn}, we can conclude
that there are two values of type \ACon{nat} on top of the stack
before the instruction and one value of type \ACon{nat}
afterwards. Moreover, we can say that this value is the sum of the two
values that were on top of the stack before, but we have to express
that with a constraint, i.e., a logical formula.

That is, symbolic exection of \ACon{ADDnn} introduces a new variable $v_r$ that replaces the
variables $v_x$ and  $v_y$ from the top of the stack,
and adds a clause that equates this new variable with the sum of the former two:
\[	v_r := \ACon{ADDnn}\; v_x\; v_y
\]

In this way, we can give a single symbolic execution rule for all
functional instructions that return a single result.
\AbstractProgStepDOne

Let's decompress this definition. We pattern match against the current
(abstract) state to obtain the environment {\Aaen}, the current
instruction, the stack {\Aast}, and the formula $\Phi$. The
constructor \ACon{fct} indicates a functional instruction and the
constructor \ACon{D1} indicates that $f$ returns a single result of
type \emph{result}.

As the instruction does not implement any control flow, there is only
a single next state. Its description starts with the extended context
$result :: \Gamma$, which introduces a new variable of type $result$
for the result. The name, rather the deBruijn address, of this
variable is \AZERO, which denotes the first entry in the context. The
second component describes the new state, which (ignoring the
\AFun{wk} functions for the moment) keeps the environment, moves to
the rest of the program, pushes the result on the stack after removing
the arguments using \AFun{H.rest}, and pushes a new equation that
defines the value of {\AZERO} as the result of applying $f$ to the
front of the stack.
The functions \AFun{H.front} and \AFun{H.rest} operate on heterogenous
lists and are defined such that
$\Aast \equiv \AFun{H.front}~\Aast~\AFun{H.++}~\AFun{H.rest}~\Aast$ where
the actual division is driven by the type of $f$. The operation
$\AFun{H.++}$ is concatenation of heterogenous lists.
The \AFun{wk} functions are a consequence of using deBruijn indices
for variables: if we introduce new variables, all existing variables
have to be incremented by the number of new variables (i.e.,
weakened). We do not show their definition, 
as this manipulation of deBruijn indices is standard.

%% listing ruler max width ------------------------------------------------|?X

\begin{figure}[tp]
  \AbstractProgStepUNPAIR
  \AbstractProgStepSWAP
  \AbstractProgStepPUSH
  \caption{Functional instructions (excerpt)}
  \label{fig:aprog-step-func}
\end{figure}

\begin{comment}
  The matching representing the stack can be split implicitly just
  like the stack interpretation during concrete execution.  \verb/n∈/
  is another Agda pattern synonym for the n'th element of the context.
  Whenever the context is extended during symbolic execution, all
  elements of the abstract program state that do not change must be
  weakened so they can be parameterized by the new context.
\end{comment}
We do not have a general mechanism for the other functional
instructions (see~\autoref{fig:aprog-step-func}), as they behave very differently in a symbolic context:
\ACon{UNPAIR} requires two new variables and clauses, while
\ACon{SWAP} only changes the position of two stack values
so the entire change is encoded in the state of the stack
and no new clauses or variables are necessary.

The instruction \ACon{PUSH} needs special treatment because it can
handle arbitrarily complex compound values.
When pushing a value $x$ of primitive type, it is sufficient to add a new variable
and a clause which sets this variable equal to the term $\ACon{const}~x$.
But if $x$ has a list type or an option type, its value cannot be
expressed with a \ACon{const} term, in general.
To this end, the function $\AFun{unfold}~P~x$ creates all clauses required
to express the value $x$. This process defines a list of new variables
of types defined by $\AFun{expandΓ}~ P~ x$.\footnote{We do not include
the tedious definitions of these auxiliary functions here, but
encourage the interested reader to check the supplementary material.}
For example, $\ACon{PUSH}~\{\ACon{list ty}\}~P~(y~\ACon{∷}~ ys)$ gives
rise to two new variables $r_y$ of type
\ACon{ty} for $y$ and $r_{ys}$ of type \ACon{list ty} for $ys$ and an
equation $r := \ACon{func}~(\ACon{CONS}~[r_y, r_{ys}])$, where $r$ is the variable
for the result. The function \AFun{unfold} proceeds recursively:
if $ys = []$, its variable can be set to $\ACon{func}~(\ACon{NIL}~ty)~[]$,
otherwise it will be further decomposed.
Similarly for $y$: if $ty$ is a primitive type, it can be set to $\ACon{const}~y$,
otherwise it must be further decomposed as well.
% This process is arbitrarily complex, but of course finite ;)

\begin{comment}
  When \verb/UNPAIR/ is executed on a variable \verb/p∈/, and it is
  known about \verb/p∈/ that it is a \verb/PAIR/ of two other
  variables \verb/v₁∈/ and \verb/v₂∈/, there is no need to introduce
  two new variables and express their values with respect to \verb/p∈/
  as the generic \verb/αprog-step/ would (see
  \listref{aprog-step-func}).  These new variables would be equal to
  \verb/v₁∈/ and \verb/v₂∈/ and it is better to use them instead.
\end{comment}
\begin{comment}
  Also, when the argument values for a onedimensional function are all
  given as constant terms (which is formalized by the
  \verb/MatchConst Φ Margs/ construct that associates every argument
  variable \verb/v∈/ from \verb/Margs/ with a clause
  \verb/v∈ := const x/ in \verb/Φ/), it is not necessary to express
  the value of the result in a functional term since it can just be
  calculated.
\end{comment}
\begin{comment}
  \listref{a-ITER'} shows some symbolic execution rules for the
  \verb/ITER'/ instruction: Generally, when no further information
  about the relevant list variable is present, symbolic execution will
  lead to a disjunction that considers both possibilities.  But if
  some relevant information is known about that variable, the
  disjunction as well as the context extension can be avoided.

  \begin{listing}[!ht]
\begin{minted}{agda}
αprog-step {Γ} α@(αstate αen (ITER' {ty} x ∙ prg) rVM (l∈ ∷ sVM) Φ)
  = [ _ , record α{ prg = prg ; sVM = sVM 
                  ;   Φ = [ l∈ := func (NIL ty) [M] // Φ ] }
    / [ ty / list ty // Γ ]
    , αstate (wkαE αen) (x ;∙ ITER' x ∙ prg) (0∈ ∷ wkM rVM) (1∈ ∷ wkM sVM)
             [ 2+ l∈ := func CONS (0∈ ∷ 1∈ ∷ [M]) // wkΦ Φ ] ]

  ITER'c : ∀ {αen ty l∈ x∈ xs∈ Φ rS sS iterate prg rVM sVM}
         → l∈ := func CONS (x∈ ∷ xs∈ ∷ [M])  ∈  Φ
         → αρ-special
               (αstate αen (ITER' {ty} {rS} {sS} x ∙ prg) rVM  (l∈ ∷ sVM) Φ)
           (_ , αstate αen (x ;∙ ITER' x ∙ prg)    (x∈ ∷ rVM) (xs∈ ∷ sVM) Φ)
\end{minted}
\caption{Exemplary symbolic execution rules for ITER'}
\label{a-ITER'}
\end{listing}

It is possible to reach the same logical conclusions as
\verb/αρ-special/ by first performing a generic symbolic execution
step with \verb/αprog-step/ and then applying some first order
conclusions on the resulting formula.  For example in the case of
\verb/ITER'/, if it is known that \verb/l∈/ is \verb/CONS/ and the
first disjunct from \verb/αprog-step/ adds the clause that sets it
equal to \verb/NIL/, a contradiction can be concluded from these two
clauses and the entire disjunct can be set to false and discarded.

Such rules and their soundness have already been successfully
implemented and proven in an earlier version of the model.  But since
they come at a great performance cost by requiring more conclusion
steps and creating new redundant variables most of the time, these
rules where replaced by the given special relation transitions during
a major rework of the model.
\end{comment}

\begin{figure}[tp]
  \AbstractProgStepIFNONE
  \caption{Symbolic execution of \ACon{IF-NONE}}
  \label{fig:sym-exec-if-none}
\end{figure}
We finish with the abstract execution of the conditional instruction
\ACon{IF-NONE} (see~\autoref{fig:sym-exec-if-none}). This instruction
expects a value of type $\ACon{option}~t$ on top of the stack. Here we have two
possible next states, depending on whether the value is present. The
first disjunct deals with the case where the value is \ACon{NONE}. In
this case, the stack is popped, the \emph{thn} branch is taken, and
the equation enforcing the value to be \ACon{NONE} is added. There are
no new variables, so there is no weakening in this disjunct.

The second disjunct models the case where the value on top of the stack is
$\ACon{SOME}~y$. Here we need a new variable of type $t$ for $y$, pop
the stack and push the new variable, we take the \emph{els} branch,
and add an equation that forces the value to be $\ACon{SOME}~y$.

\subsection{Calculus for the DL on Blockchain Operations}
\label{sec:calc-dl-blockch}

Just like the symbolic execution rules for the Michelson DL,
those for the DL on blockchain operations
are given analogously.
\AbstractUExecState
\AbstractAexecStep


%% listing ruler max width ------------------------------------------------|?X
% \begin{listing}[!ht]
% \begin{minted}{agda}
% record αExec-state Γ : Set where
%   constructor αexc
%   field
%     αccounts : βlockchain Γ
%     αρ⊎Φ     : αPrg-running Γ ⊎ List (Formula Γ)
%     pending  : List (list ops ∈ Γ × ⟦ base addr ⟧)

% ⊎Exec-state = List (∃[ Γ ] αExec-state Γ)

% αexec-step : ∀ {Γ} → αExec-state Γ → ⊎Exec-state

% data ασ-special {Γ} : αExec-state Γ → ⊎Exec-state → Set where
% \end{minted}
% \caption{Symbolic execution rules for abstract execution states}
% \label{aexec-all}
% \end{listing}

The switch from concrete to abstract execution state is achieve by
changing the $Mode$ parameter of the \ADT{ExecState} (see
\autoref{fig:contract-execution-state}). Its $\mathcal{F}$ field
replaces concrete semantics by abstract semantics throughout all state
components. 


Unfortunately \AFun{αexec-step} cannot represent \AFun {exec-step}
exactly, if \AField{MPstate} is \ACon{Cont}~$\Phi$, that is: a
contract has terminated and we need to check the \AField{pending}
field for further operations to be executed. 
At this point, the predicate $\Phi$ has to supply sufficient information about the values of the variables
representing the pending operations to proceed in a meaningful way.
The \AField{pending} list contains pairs of a list of operations and a
sender address. While the latter is a concrete address, the former is
a variable of type \verb/list operation ∈ Γ/. To proceed, we have to
know if the list  is empty (so that we can proceed to the next block
of pending operations) or not. In the latter case, we need to ensure
that the first element of the operation list is a
\ACon{TRANSFER-TOKENS}, and so on.

To this end, we defined several auxiliary functions to inspect the
constraints in $\Phi$ for patterns that restrict the models
sufficiently. For example, the function \AFun{find-tt-list} takes a
conjunction of formulas and a variable of type $\ACon{list}~t$ and
tries to find a formula that restricts this variable to \ACon{NIL} or
\ACon{CONS}:
\AbstractFindTTList
\SoundnessFindTTList

We only show the soundness lemma for \ACon{NIL}, as the one for
\ACon{CONS} is analogous. This approach is not complete as the
implementation of \AFun{find-tt-list} is tailored to the constraints
as they are produced by symbolic execution. 

The full implementation is quite involved and relies on several
further lemmas that examine constraints (for example if the current
balance of a sender is sufficient for a token transfer) in a similar
way. We refer the interested reader to the supplement.

The remaining cases deal with a terminated contract execution where
the new state is written back to the blockchain or the execution of an abstract program step for the contract under execution.
The first case is similar to the concrete implementation where new variables are introduced
for the updated values.
The second case is more complicated because the context extensions from the abstract program step
are encoded in the list of resulting disjunctions,
so an additional term has to be supplied proving that these contexts are actually an extension
of the original context.


\begin{comment}
\verb/αPrg-running/ is the same as its non-abstract counter part holding abstract contracts
and program states instead of concrete ones.

Besides using an abstract variant of \verb/blockchain/, the abstract version of the execution state
also differes in its other fields.
In the concrete setting, the new values for the contracts storage and balance
are written directly to the \verb/accounts/,
but the abstract contracts only hold variables for these entities, who's values are only
described by $\Phi$.
So when an abstract contract execution terminates, all of the information stored in
\verb/αPrg-running/ can be discarded, except for the formulas which will be stored
in case no contract is executed in the current state.
Also, since the emitted blockchain operations will also be stored as variables,
\verb/pending/ holds such variables instead of actual operations.

%% listing ruler max width ------------------------------------------------|?X
\begin{listing}[!ht]
\begin{minted}{agda}
record αProg-state Γ {ro so : Stack} : Set where
  constructor αstate
  field
    {ri si} : Stack
    αen : αEnvironment Γ
    prg : ShadowProg ri si ro so
    rVM : Match Γ ri
    sVM : Match Γ si
    Φ   : List (Formula Γ)

record αExec-state Γ : Set where
  constructor αexc
  field
    αccounts : βlockchain Γ
    αρ⊎Φ     : αPrg-running Γ ⊎ List (Formula Γ)
    pending  : List (list ops ∈ Γ × ⟦ base addr ⟧)
\end{minted}
\caption{Single abstract program and execution states}
\label{abstract-states}
\end{listing}

During symbolic execution, unlike in a concrete setting, execution is not deterministic
since the values for variables necessary for case distinctions may not be present in the current
execution state, i.e. $\Phi$.
This is modelled by giving abstracts states
as disjunctions of the states from \listref{abstract-states}:
%% single line listing ruler max width ------------------------------------------------|X
\mint{agda}|⊎Prog-state = λ {ro} {so} → List (∃[ Γ ] αProg-state Γ {ro} {so})|
\mint{agda}|⊎Exec-state = List (∃[ Γ ] αExec-state Γ)|

It is necessary to place the disjunctions on the level of abstract program and execution states
rather than defining disjunctions on the level of formulas,
because when they occure due to the symbolic execution of a given abstract state,
the resulting states also differ in the resulting stack matchings and rest program
(in case of a program state) or the resulting current execution state \verb/αρ⊎Φ/.

Using Agda Lists to represent conjunctions and disjunctions is conveniet because
\begin{enumerate}
	\item	within any of the given listing constructs ($\Phi$, \verb/αXxxx-state/)
		all elements are interpreted exclusively as con- or disjuncts,
		so defining them separately would only yield another list like structure.
	\item	some rules of the calculus as well as the semantics for our model
		can make efficient use of the element relation for Agda Lists.
\end{enumerate}

Note that while the storage and balance of abstract contract are modeled with respective variables,
their addresses on the abstract blockchain are \emph{NOT} modeled with variables but rather
with given values like in the concrete setting.
Abstracting them would be possible, but it wouldn't make the logic any more expressive
since cases where an address value on the stack is not known can still be modelled,
and having abstract contract addresses would only effect the symbolic execution of a
\verb/TRANSFERE-TOKEN/ operation \todo{annoying to formulate \ldots!!!!!!}

We give the calculus in a different way (as mentioned in \secref{sec:abstract-states})
by giving rules that will add new formulas to those already saved in the abstract states
for the abstract execution of the next instruction (or operation).
Or rather it will give a new abstract state disjunction that represents a formula
which is valid if the formula represented by the initial state
was valid before instruction execution (as we will proof in \chapref{chap:soundness}).

They are given in two different forms:

One gives the conclusion formula in a deterministic way that can always be applied to any
possible Michelson instruction, regardless of the values that may or may not be
provided for the relevant variables by the premise formula.
This resembles the deterministic execution of concrete states and is achieved
by accordingly named functions:
%% single line listing ruler max width ------------------------------------------------|X
\mint{agda}|αprog-step : ∀ {Γ ro so} → αProg-state Γ {ro} {so} → ⊎Prog-state {ro} {so}|
\mint{agda}|αexec-step : ∀ {Γ} → αExec-state Γ → ⊎Exec-state|

While in the concrete case, any kind of functional instruction can be performed by the compact
definition given in \listref{prog-step}, this can only be achieved for the subset of
onedimensional functions here (see \listref{aprog-step}):

%% listing ruler max width ------------------------------------------------|?X
\begin{listing}[!ht]
\begin{minted}{agda}
αprog-step {Γ} (αstate αen (fct (D1 {result} f) ; prg) rVM sVM Φ)
  = [ [ result // Γ ]
    , (αstate (wkαE αen) prg (0∈ ∷ wkM (Mbot rVM)) (wkM sVM)
              [ 0∈ := wk⊢ (func f (Mtop rVM)) // wkΦ Φ ]) ]

αprog-step {Γ} (αstate αen (fct (Dm (UNPAIR {t1} {t2})) ; prg)
                       (p∈ ∷ rVM) sVM Φ)
  = [ [ t1 / t2 // Γ ]
    , (αstate (wkαE αen) prg (0∈ ∷ 1∈ ∷ wkM rVM) (wkM sVM)
              [ 0∈ := wk⊢ (func CAR (p∈ ∷ [M]))
              / 1∈ := wk⊢ (func CDR (p∈ ∷ [M])) // wkΦ Φ ]) ]
αprog-step α@(αstate αen (fct (Dm SWAP) ; prg) (x∈ ∷ y∈ ∷ rVM) sVM Φ)
  = [ _ , record α{ prg = prg ; rVM = y∈ ∷ x∈ ∷ rVM } ]
αprog-step α@(αstate αen (fct (Dm DUP)  ; prg) (x∈      ∷ rVM) sVM Φ)
  = [ _ , record α{ prg = prg ; rVM = x∈ ∷ x∈ ∷ rVM } ]

αprog-step {Γ} (αstate αen (fct (PUSH P x) ; prg) rVM sVM Φ)
  = [ (expandΓ P x ++ Γ)
    , (αstate (wkαE αen) prg ((∈wk (0∈exΓ P)) ∷ wkM rVM) (wkM sVM)
              (Φwk (unfold P x) ++ wkΦ Φ)) ]
\end{minted}
\caption{Deterministic symbolic program state execution}
\label{aprog-step}
\end{listing}

It is possible for those functions since they double as the functional terms
that can be expressed in the DL.
A new variable of the result type is added to the Context and a new conjunct to $\Phi$,
stating that the new variable equals the term
that applies the argument variables from the top of the stack matching to that function.
The weakening operators \verb/wk/\emph{XY} accommodate for the new context.

For other functions, no generic symbolic execution is possible:
In case of the \verb/UNPAIR/ instruction, two new variables and corresponding clauses must be added,
while for \verb/SWAP/ and \verb/DUP/ nothing has to be added
(hence the context doesn't change, which Agda knows implicitly , and no weakenings are applied)
and only the variables on the top of the main stack matching must be changed.

\verb/PUSH P x/ is a special case for the abstract execution as mentioned before:
When pushing a basic type, an according variable and a clause
setting it equal to the \verb/const/ term \verb/x/ (see \listref{terms-formulas}) can be added.
In case of a complex type, \verb/x/ must be decomposed into
several new variables and clauses for those that represent \verb/x/
(e.g.: \verb/PUSH (list {ty} P) (y ∷ ys)/ would be decomposed into two new variables of type
\verb/ty/ and \verb/list ty/ where the first would be set to \verb/y/ and the second to \verb/ys/;
in case of \verb/ys = []/ that would be \verb/func (NIL ty) [M]/,
otherwise \verb/ys/ must be further decomposed,
as well as \verb/y/ in case \verb/ty/ is also a complex/composite type).

Abstract execution of \verb/ITER/ works just like the concrete case (see \listref{aITER}),
but while the top element of the shadow stack interpretation can be matched
to the only two possible values for the concrete execution
(an empty or non-empty list, see \listref{prog-step}),
this isn't possible for the variable \verb/l∈/
on top of the shadow stack matching in the abstract case.
So instead of giving two possible execution rules, only one is given that introduces a
disjunction for the two possibilities that can arise:

%% listing ruler max width ------------------------------------------------|?X
\begin{listing}[!ht]
\begin{minted}{agda}
αprog-step α@(αstate αen (ITER x ; prg) (l∈ ∷ rVM) sVM Φ)
  = [ _ , record α{ prg = ITER' x ∙ prg ; rVM = rVM ; sVM = l∈ ∷ sVM } ]

αprog-step {Γ} α@(αstate αen (ITER' {ty} x ∙ prg) rVM (l∈ ∷ sVM) Φ)
  = [ _ , record α{ prg = prg ; sVM = sVM 
                  ;   Φ = [ l∈ := func (NIL ty) [M] // Φ ] }
    / [ ty / list ty // Γ ]
    , αstate (wkαE αen) (x ;∙ ITER' x ∙ prg) (0∈ ∷ wkM rVM) (1∈ ∷ wkM sVM)
             [ 2+ l∈ := func CONS (0∈ ∷ 1∈ ∷ [M]) // wkΦ Φ ] ]
\end{minted}
\caption{Generic abstract execution for ITER}
\label{aITER}
\end{listing}

However, it may be possible that the premise includes additional information about \verb/l∈/,
if a clause is present in $\Phi$ where its stated to be equal to some term.
If that term happens to be either \verb/func (NIL ty) [M]/ or \verb/func CONS (x∈ ∷ xs∈ ∷ [M])/,
one case can savely be discarded.
To enable the DL to reach such conclusions, the following relation on abstract program states
is defined:

%% listing ruler max width ------------------------------------------------|?X
\begin{listing}[!ht]
\begin{minted}{agda}
data αρ-special {Γ ro so} :         αProg-state        Γ  {ro} {so}
                          → ∃[ Γ` ] αProg-state (Γ` ++ Γ) {ro} {so}
                          → Set where

  ITER'c : ∀ {αen ty l∈ x∈ xs∈ Φ rS sS iterate prg rVM sVM}
         → l∈ := func CONS (x∈ ∷ xs∈ ∷ [M])  ∈  Φ
         → αρ-special
               (αstate αen (ITER' {ty} {rS} {sS} x ∙ prg) rVM  (l∈ ∷ sVM) Φ)
           (_ , αstate αen (x ;∙ ITER' x ∙ prg)    (x∈ ∷ rVM) (xs∈ ∷ sVM) Φ)
\end{minted}
\caption{Special case (e.g. ITER' for CONS case)}
\label{arho-special}
\end{listing}

This also has the advantage that no new variables have to be introduced.

The same conclusion could have been drawn from first performing the generic case that will
create a disjunction, and then concluding a contradiction from the other clause
by a rule that sets $\Phi$\verb/ = `false/ when two contradicting clauses like
\verb/l∈ := func (NIL ty) [M]/ and \verb/l∈ := func CONS (x∈ ∷ xs∈ ∷ [M])/ for the same variable
are contained in $\Phi$.

Such rules have already been successfully implemented and proofen
in an earlier version of the model.
But since they come at a great performance cost by requiring 3 conclusion steps instead of one
and often creating new variables that make additional conclusions necessary to connect them,
these rules where not reimplemented during a major rework of the code.

As for abstract program states, the symbolic execution of abstract execution states
is also given once in a deterministic manner as mentioned above,
but also by a similar relation for special cases.

There is a significant difference however: 
When checking \verb/pending/ for further operations to be executed,
without further knowledge about the variables representing these operations,
no meaningful action can be performed to advance the symbolic execution process.
To execute any succeeding operation, it must be at least given that
\verb/list ops ∈ Γ/ is \verb/CONS/ of such an operation variable,
which in turn must also be given to have the value of a \verb/TRANSFERE-TOKENS/ term,
for which the \verb/contract/ variable must be given a value as well.
Without such additional information, which cannot be considered for the deterministic case,
the symbolic execution can only create a case distinction between the list of operations
being either empty or filled with at least one operation which still cannot be processed
due to the missing information.
Therefore the abstract execution step function cannot reflect the exact behaviour of its
concrete counterpart, and only for those cases where the abstract state contains a
contract under execution will the soundness of the symbolic execution be prooven.

\end{comment}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "itp2024"
%%% End:
