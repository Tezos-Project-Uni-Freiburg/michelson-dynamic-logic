\section{Dynamic Logic for Michelson}
\label{sec:DL}

To obtain a dynamic logic suitable for symbolic execution we follow
the Key approach \cite{KeY3} and extend
first order logic with a modality $[p]$, where $p$ is a program state. The
intuitive meaning is that $[p]\Psi$ holds for a formula $\Psi$, if
running $p$ terminates in a state such that $\Psi$ holds. That is, the
formula $\Phi \to [p]\Psi$ has a similar meaning as the Hoare triple
$\{\Phi\}~p~\{ \Psi\}$.

In the following, we concentrate on the proof rules for the
modality. For instance (and ignoring the details of the program state
for now), $\Phi \to [end]\Psi \equiv \Phi \to \Psi$ if the program is
empty. Many simple proof rules have the form $\Phi \to [i; p]\Psi \equiv \Phi_i
\wedge\Phi \to  [p]\Psi$ where the formula $\Phi_i$ describes the effect of
instruction $i$. If the instruction is a branch instruction on a
predicate $Q$, like $\mathtt{if}~Q~p_1~p_2$, the resulting formula is a
disjunction as in $\Phi \to [(\mathtt{if}~Q~p_1~p_2); p]\Psi \equiv Q
\wedge \Phi \to [p_1; p]\Psi \vee \neg Q \wedge \Phi \to  [p_2; p]\Psi$.

We start by defining the formulas of the logic in \autoref{sec:terms-formulas}.

\subsection{Terms and Formulas}\label{sec:terms-formulas}
\begin{figure}[tp]
  \AbstractTerm
  \AbstractFormula
  \caption{Terms and formulas}
  \label{fig:terms-and-formulas}
\end{figure}

At the core of any symbolic execution there are symbolic (i.e., logical) variables
representing the unknown operands.
We represent such variables by a typed deBruijn index into a given
{\AbstractContext}.
An abstract stack is then a list of typed variables:
\AbstractMatch

Any knowledge that we have about the values on the stack is encoded in
the list of formulas (over the variables on the stack) that we
maintain in the program state.
\autoref{fig:terms-and-formulas} shows the terms and formulas used for the logic.
Term comprise variables, constants of base type and of contract type,
and simple functions. Here, ``function'' stands for proper functions as
well as data constructors. For convenience, we restrict function arguments
to variables and rely on variable equality in the formulas to specify
complex terms.

As an example for the interplay between context, stack, and formulas,
suppose the context defines three variables of type 
\ACon{nat} like this {\ExamplesContext}. An abstract stack for this
context might just contain a single variable {\ExamplesXZero}, where
the $0\in$ refers to the first variable in $\Gamma_1$.
\ExamplesAStack
If we further
want to enforce that $x = y + 3$ (on natural numbers), then we have to
encode that in two simple formulas, one that associates $3$ to
variable $v$, and another that states $x = y + v$. We do not impose a
constraint on $y$, so it serves as an unconstrained symbolic variable.
\ExamplesEqnPlus
 % \begin{minipage}[t]{0.45\linewidth}
 %   \ExamplesEqnList
 % \end{minipage}
% The term for subtracting mutez' is not representable with a functional Michelson instruction
% and therefore defined as a separate term.

Formulas are mainly used to express equality of a variable with a
term. The inequalities express the ordering on tokens. The latter is used for token transfers
where we have to know that the sender has sufficiently many tokens to satisfy
the requirements of the transfer. The reader may wonder about 
conjunction and disjunction: the proof rules only generate them in the
form of a disjunction of conjunctions of simple formulas.  We
represent this structure as a list of lists of simple
formulas. Repetition does not matter in this
representation for two reasons: 1. disjunction and conjunction are
both idempotent; 2. we are only interested in validity of a formula,
but do not transform it in any way.


\subsection{Representing Michelson Program State in DL}
\label{sec:abstract-states}

We simplify the handling of formulas of the form $\Phi \to [p]\Psi$ by
reusing our previous definition of the type \ADT{ProgState} in a
different mode as an \emph{abstract} state.
\AbstractAMode
That is, we replace the normal representation of values in $\mathcal M$ by symbolic
variables, in $\mathcal{F}$ we maintain a list (i.e., conjunction) of
formulas, and in $\mathcal{G}$ we maintain a tagged list of formulas
to represent different modes of failure. 

The meaning of an abstract state is a conjunction that specifies the
value for \ACon{AMOUNT} and \ACon{BALANCE} in the environment, it
specifies the size of the stack and all values on it, and it collects
further constraints generated by application of the proof rules.




Informally, an abstract program state
represents $\Theta \Longrightarrow [ prg ] \Psi$ where
\begin{align*}
	\Theta&\equiv	\text{\emph{state of environment}} = \AFun{en}
\land	\text{\emph{state of stack}} = \AFun{stk}
\land	\bigwedge_{\phi \in \Phi} \phi
\end{align*}

The encoding of the implication in the abstract program state
corresponds exactly to the abstract instance of the 
\ADT{ProgState} type (see \autoref{fig:prog-step-example}). Reusing the type in this way makes the
formalization of symbolic execution very similar to the concrete
execution model presented in~\autoref{sec:refImpl}.
This similarity in turn makes the soundness proof easier and more concise.
All constructs for concrete execution are reused in the abstract by
instantiating their \ADT{MODE} parameter.
Thus, they  are automatically parameterized by a \verb/Context Γ/ and the names of the
structures are the same as for concrete execution but prefixed with an \verb/α/
(only the abstract blockchain is called \verb/βlockchain/).


Symbolic execution of control flow can lead to disjunctions over such
states, which is represented using a list of abstract program
states. Each of the branch comes with its own state, which requires
existential quantification over the types of the variables in $\Gamma$.
\AbstractUProgState
% \mint{agda}|⊎Prog-state = λ {ro} {so} → List (∃[ Γ ] αProg-state Γ {ro} {so})|

Using Agda lists to represent conjunctions and disjunctions is
convenient for two reasons.
\begin{enumerate}
\item Conjunctions and disjunctions do not mix: $\Phi$ always represents a conjunction over its elements
  and disjunctions can only occur as a result of some
  symbolic execution rules that implement control flow. 
  In this case, the disjunction always affects every aspect of the abstract program state
  (i.e., the remaining programs will always differ).
\item Agda's ``element of'' relation for lists makes the
  implementation of the rules of the calculus simple and efficient.
\end{enumerate}

\subsection{Proof Rules for Michelson}
\label{sec:calculus}

The rules for symbolic execution are formalized by a function that
maps an abstract program state into a set (list) of abstract program states.
\AbstractProgStep

It mimics \AFun{prog-step} and gives a deterministic way of symbolic execution.
Every (non-environmental) functional instruction can be executed concretely
with a single rule as shown in \autoref{fig:exec-step-1}.
During symbolic execution, the only thing that is guaranteed is
that the stacks contain values of the expected type.
For example, if the next instruction is \ACon{ADDnn}, we can conclude
that there are two values of type \ACon{nat} on top of the stack
before the instruction and one value of type \ACon{nat}
afterwards. Moreover, we can say that this value is the sum of the two
values that were on top of the stack before, but we have to express
that with a constraint, i.e., a logical formula.

That is, symbolic execution of \ACon{ADDnn} introduces a new variable $v_r$ that replaces the
variables $v_x$ and  $v_y$ from the top of the stack,
and adds a clause that equates this new variable with the sum of the former two:
\[	v_r := \ACon{ADDnn}\; v_x\; v_y
\]

In this way, we can give a single symbolic execution rule for all
functional instructions that return a single result.
\AbstractProgStepDOne

Let's decompress this definition. We pattern match against the current
(abstract) state to obtain the environment {\Aaen}, the current
instruction, the rest of the program \textit{prg}, the stack {\Aast}, and the formula $\Phi$. The
constructor \ACon{fct} indicates a functional instruction and the
constructor \ACon{D1} indicates that $f$ returns a single result of
type \emph{result}.

As the instruction does not implement any control flow, there is only
a single next state. Its description starts with the extended context
$result :: \Gamma$, which introduces a new variable of type $result$
for the result. The name, rather the deBruijn address, of this
variable is \AZERO, which denotes the first entry in the context. The
second component describes the new state, which (ignoring the
\AFun{wk} functions for the moment) keeps the environment, moves to
the rest of the program, pushes the result on the stack after removing
the arguments using \AFun{H.rest}, and pushes a new equation that
defines the value of {\AZERO} as the result of applying $f$ to the
front of the stack.
The functions \AFun{H.front} and \AFun{H.rest} operate on heterogenous
lists and are defined such that
$\Aast \equiv \AFun{H.front}~\Aast~\AFun{H.++}~\AFun{H.rest}~\Aast$ where
the actual division is driven by the type of $f$. The operation
$\AFun{H.++}$ is concatenation of heterogenous lists.
The \AFun{wk} functions are a consequence of using deBruijn indices
for variables: if we introduce new variables, all existing variables
have to be incremented by the number of new variables (i.e.,
weakened). We do not show their definition, 
as this manipulation of deBruijn indices is standard.

%% listing ruler max width ------------------------------------------------|?X

\begin{figure}[tp]
  \AbstractProgStepUNPAIR
  \AbstractProgStepSWAP
  \AbstractProgStepPUSH
  \caption{Functional instructions (excerpt)}
  \label{fig:aprog-step-func}
\end{figure}

We do not have a general mechanism for the other functional
instructions (see~\autoref{fig:aprog-step-func}), as they behave very differently in a symbolic context:
\ACon{UNPAIR} requires two new variables and clauses, while
\ACon{SWAP} only changes the position of two stack values.
No new variables or clauses are necessary because \ACon{SWAP} only
reconfigures the stack.

The instruction \ACon{PUSH} needs special treatment because it can
handle arbitrarily complex compound values.
When pushing a value $x$ of primitive type, it is sufficient to add a new variable
and a clause which sets this variable equal to the term $\ACon{const}~x$.
But if $x$ has a list type or an option type, its value cannot be
expressed with a \ACon{const} term. In general, the symbolic execution
of a single \ACon{PUSH} instruction may create arbitrarily many (but
linear in the size of the pushed value) new variables and clauses.

To this end, the function $\AFun{unfold}~P~x$ creates all clauses required
to express the value $x$. This process defines a list of new variables
of types defined by $\AFun{expandΓ}~ P~ x$.\footnote{We do not include
the tedious definitions of these auxiliary functions here, but
encourage the interested reader to check the supplementary material.}
For example, $\ACon{PUSH}~\{\ACon{list ty}\}~P~(y~\ACon{∷}~ ys)$ gives
rise to two new variables $r_y$ of type
\ACon{ty} for $y$ and $r_{ys}$ of type \ACon{list ty} for $ys$ and an
equation $r := \ACon{func}~(\ACon{CONS}~[r_y, r_{ys}])$, where $r$ is the variable
for the result. The function \AFun{unfold} proceeds recursively:
if $ys = []$, its variable can be set to $\ACon{func}~(\ACon{NIL}~ty)~[]$,
otherwise it will be further decomposed.
Similarly for $y$: if $ty$ is a primitive type, it can be set to $\ACon{const}~y$,
otherwise it must be further decomposed as well.

As an example, we show the result of unfolding the list $[0, 1] : \ACon{list nat}$. 
The generated context is {\ExamplesContextList} and the generated list
of equations to represent the list is as follows.
\ExamplesEqnList


\begin{figure}[tp]
  \AbstractProgStepIFNONE
  \caption{Symbolic execution of \ACon{IF-NONE}}
  \label{fig:sym-exec-if-none}
\end{figure}
We finish with the abstract execution of the conditional instruction
\ACon{IF-NONE} (see~\autoref{fig:sym-exec-if-none}). This instruction
expects a value of type $\ACon{option}~t$ on top of the stack. Here we have two
possible next states, depending on whether the value is present. The
first disjunct deals with the case where the value is \ACon{NONE}. In
this case, the stack is popped, the \emph{thn} branch is taken, and
the equation enforcing the value to be \ACon{NONE} is added. There are
no new variables, so there is no weakening in this disjunct.

The second disjunct models the case where the value on top of the stack is
$\ACon{SOME}~y$. Here we need a new variable of type $t$ for $y$, pop
the stack and push the new variable, we take the \emph{els} branch,
and add an equation that forces the value to be $\ACon{SOME}~y$.

\subsection{Proof Rules for the Blockchain Run-time}
\label{sec:calc-dl-blockch}

Just like the symbolic execution rules for the Michelson DL,
those for the DL on blockchain operations
are given analogously.
\AbstractUExecState
\AbstractAexecStep


%% listing ruler max width ------------------------------------------------|?X
% \begin{listing}[!ht]
% \begin{minted}{agda}
% record αExec-state Γ : Set where
%   constructor αexc
%   field
%     αccounts : βlockchain Γ
%     αρ⊎Φ     : αPrg-running Γ ⊎ List (Formula Γ)
%     pending  : List (list ops ∈ Γ × ⟦ base addr ⟧)

% ⊎Exec-state = List (∃[ Γ ] αExec-state Γ)

% αexec-step : ∀ {Γ} → αExec-state Γ → ⊎Exec-state

% data ασ-special {Γ} : αExec-state Γ → ⊎Exec-state → Set where
% \end{minted}
% \caption{Symbolic execution rules for abstract execution states}
% \label{aexec-all}
% \end{listing}

The switch from concrete to abstract execution state is achieve by
changing the $Mode$ parameter of the \ADT{ExecState} (see
\autoref{fig:contract-execution-state}). Its $\mathcal{F}$ field
replaces concrete semantics by abstract semantics throughout all state
components. 


Unfortunately \AFun{αexec-step} cannot represent \AFun {exec-step}
exactly, if \AField{MPstate} is \ACon{Cont}~$\Phi$, that is: a
contract has terminated and we need to check the \AField{pending}
field for further operations to be executed. 
At this point, the predicate $\Phi$ has to supply sufficient information about the values of the variables
representing the pending operations to proceed in a meaningful way.
The \AField{pending} list contains pairs of a list of operations and a
sender address. While the latter is a concrete address, the former is
a variable of type \verb/list operation ∈ Γ/. To proceed, we have to
know if the list  is empty (so that we can proceed to the next block
of pending operations) or not. In the latter case, we need to ensure
that the first element of the operation list is a
\ACon{TRANSFER-TOKENS}, and so on.

To this end, we defined several auxiliary functions to inspect the
constraints in $\Phi$ for patterns that restrict the models
sufficiently. For example, the function \AFun{find-tt-list} takes a
conjunction of formulas and a variable of type $\ACon{list}~t$ and
tries to find a formula that restricts this variable to \ACon{NIL} or
\ACon{CONS}:
\AbstractFindTTList
\SoundnessFindTTList

We only show the soundness lemma for \ACon{NIL}, as the one for
\ACon{CONS} is analogous. This approach is not complete as the
implementation of \AFun{find-tt-list} is tailored to the constraints
as they are produced by symbolic execution. 

The full implementation is quite involved and relies on several
further lemmas that examine constraints (for example if the current
balance of a sender is sufficient for a token transfer) in a similar
way. We refer the interested reader to the supplement.

The remaining cases deal with a terminated contract execution where
the new state is written back to the blockchain or the execution of an abstract program step for the contract under execution.
The first case is similar to the concrete implementation where new variables are introduced
for the updated values.
The second case is more complicated because the context extensions from the abstract program step
are encoded in the list of resulting disjunctions,
so an additional term has to be supplied proving that these contexts are actually an extension
of the original context.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "itp2024"
%%% End:
